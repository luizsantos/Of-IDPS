/**
 * Manage attack memory using autonomic techniques to create security 
 * rules that will help to protect the network against security threats.
 * 
 * @author Luiz Arthur Feitosa dos Santos
 * @email luiz.arthur.feitosa.santos@gmail.com
 * 
 * TODO 1. Discover how long time a rule or alert must be in short memory?
 * 
 * TODO 2. When arriving packets match to installed security rules, 
 * this rules must be maintained for more time in the system. 
 * 
 * TODO 3. Must be implemented the alteration of already installed switches flows, to avoid overhead. For instance, the ability of change the bandwidth from an already installed flow in switches. 
 *  For now, to change one existent flow we needed:
 *      (i) delete this flow on the switch,
 *      (ii) wait that this same flows will be request by the hosts to the switch,
 *      (iii) the switch probably, will request this to OpenFlow controller, that will install this flow again using the new bandwidth control.
 * 
 * TODO 4 - implement a method that permit simplify/summarize
 * the rules generated by itemsets algorithm. It means, if exist a
 * specific rule that match with a more general rule, we should
 * remove this specific rule (not send this command) and only send a
 * command to delete flows via the more generic rule, therefore just
 * one delete command is send to switches and not two this probably
 * will reduce the number of interruptions in the flows and probably
 * will gain performance. ie: 
 * first rule: 10.0.0.1:*->200.0.0.1:* (ICMP) 
 * second rule: 10.0.0.1:*->*:* (ICMP) 
 * 
 * In this case should be applied just
 * the second or send a command for the seconds rule because this
 * command also contemplate the first rule.
 * 
 */


package net.OfIDPS.memoryAttacks;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


import net.beaconcontroller.IPS.AlertMessageSharePriority;
import net.beaconcontroller.IPS.IntrusionPreventionSystem;
import net.beaconcontroller.IPS.AlertMessage;
import net.beaconcontroller.core.IBeaconProvider;
import net.beaconcontroller.tools.FileManager;
import net.beaconcontroller.tutorial.ActuatorOpenFlow;
import net.beaconcontroller.tutorial.AnalysisFlow;
import net.beaconcontroller.tutorial.CONFIG;
import net.beaconcontroller.tutorial.LearningSwitchTutorialSolution;

public class MemorysAttacks extends Thread {
    
    protected IBeaconProvider beaconProvider;
    
    protected static Logger log = LoggerFactory
            .getLogger(LearningSwitchTutorialSolution.class);
    
    // Maps that represent the list of alerts security in memories.
    private Map<String,AlertMessage> shortMemoryAttacks;
    private Map<String,AlertMessage> longMemoryAttacks;
    private Map<String,AlertMessage> sensorialMemoryAttacks;
    
    /*
     * Period of time, in seconds, that an alert will be processed. This period
     * of time will be since the first time that it appear until the value in
     * this variables in seconds.
     */
    public static int timeToAlertsStayAtShortMemory= CONFIG.TIME_TO_ALERTS_STAY_AT_SHORT_MEMORY;
    public static int timeToAlertsStayAtSensorialMemory= CONFIG.TIME_TO_ALERTS_STAY_AT_SENSORIAL_MEMORY;
    public static int timeToAlertsStayAtLongMemory= CONFIG.TIME_TO_ALERTS_STAY_AT_LONG_MEMOY;
        
    /*
     * Time to wait until execute again the main method contained in the Thread (method run).
     */
    public static final int TIME_TO_WAIT= CONFIG.TIME_BETWEEN_RUN_MEMORY_ATTACKS;
    
    /*
     * USED TO IDENTIFY THE MEMORY TYPE.
     */
    public static final int SENSORIAL_MEMORY=1;
    public static final int SHORT_MEMORY=2;
    public static final int LONG_MEMORY=3;
    
    
    // Set when class start at first time!
    private static Date dateTimeStartObject = new Date();
    
    /**
     * Constructor method
     * 
     * @param shortMemoryAttacks - short memory
     * @param longMemoryAttacks - long memory
     * @param sensorialMemoryAttacks - sensorial memory
     */
    public MemorysAttacks (Map<String,AlertMessage> shortMemoryAttacks,
            Map<String,AlertMessage> longMemoryAttacks,
            Map<String,AlertMessage> sensorialMemoryAttacks) {
        this.shortMemoryAttacks=shortMemoryAttacks;
        this.longMemoryAttacks=longMemoryAttacks;
        this.sensorialMemoryAttacks=sensorialMemoryAttacks;
    }
    
    /**
     *  Start the Thread
     */
    public void run() {
        log.debug("Start Thread that is responsible to construct memory from attacks");
        while (true) {
            
            /**
             * TODO - Feed sensorial memory.
             */
            
            
            /**
             * TODO - Feed short memory.
             */
            String alertsFromIDSSnort = "";
            String alertsFromOpenFlowDoS = "";
            
            if (LearningSwitchTutorialSolution.disableOfIDPS_UseIDSAlerts != 1) {
                IntrusionPreventionSystem ids = new IntrusionPreventionSystem();
                alertsFromIDSSnort = ids.getAlertsFromSnortIDS();
                // log.debug("Alerts obtained from Snort IDS to be processed by itemsets algorithm.");
                // log.debug(alertsFromIDSSnort);
            } else {
                log.debug("\t!!!!!!!! ATTENTION, Of-IDPS IDS alerts analysis IS DISABLED, then won't be able to generate autonomic rules based on OpenFlow data!!!!!!!  to change this setup to 0 (zero) the variable disableOfIDPS_UseIDSAlerts on LearningSwithTutorialSolution class...");
            }
            
            if (LearningSwitchTutorialSolution.disableOfIDPS_UseOfAlerts != 1
                    && LearningSwitchTutorialSolution.disableOfIDPS_UseOfgetStatisticsFromNetwork != 1) {
                AnalysisFlow analysisFlow = new AnalysisFlow();
                List<AlertMessageSharePriority> listOfMaliciousFlows = new ArrayList<AlertMessageSharePriority>();
                listOfMaliciousFlows = analysisFlow.getListOfMaliciousFlows();
                alertsFromOpenFlowDoS = this.convertOpenFlowDoSAlertsToBeProcessedByItemsetsAlgorithm(listOfMaliciousFlows);
            } else {
                log.debug("\t!!!!!!!! ATTENTION, Of-IDPS ALERT OPENFLOW STATISTICS IS DISABLED, then won't be able to generate autonomic rules based on OpenFlow data!!!!!!!  to change this setup to 0 (zero) the variables disableOfIDPS_UseOfgetStatisticsFromNetwork and disableOfIDPS_UseOfAlerts on LearningSwithTutorialSolution class...");
            }
            
            // Join alerts
            String allAlerts = alertsFromIDSSnort+alertsFromOpenFlowDoS;
            
            // Obtain rules from IDS alerts using itemsets algorithm.
            Map<String,AlertMessage> ruleListFromIDS = new HashMap<String, AlertMessage>();
            ruleListFromIDS = getRulesFromIDSAlertsUsingItensetsAlgorithm(allAlerts);
            
            /*
             * Update rules on short memory and send this for all switches on the network.
             * here the delete/remove existent flows are inside of this method.
             * 
             */
            updateRulesInShortMemoryAndApplieThisRulesOnSwitches(ruleListFromIDS);
            
            /*
             * This didn't work very well: update rules on short memory, but
             * with this method all rules generated are sent for all switches
             * all the time (period that the rules are generated - 
             * waitTimeInSeconds(TIME_TO_WAIT)), then this
             * interrupt this flows and sends a lot of the OpenFlow Delete
             * messages all the time
             * 
             * If you want use this method you must implement or use a method
             * for delete/remove/update all related flows existent that already
             * are presents on the networks switches. *
             */
            //updateRulesInShortMemoryUsingSimpleMethod(ruleListFromIDS);
            
            
            /*
             * This didn't work very well:
             * TODO - The use of counter life didn't work very well, when the counter
             * is incremented by the own rules (if the rule generated is equal
             * to an existing rule)... maybe this will work if the increment it
             * is done by the new packets that match with this rules!
             * 
             * If you want use this method you must implement or use a method
             * for delete/remove/update all related flows existent that already
             * are presents on the networks switches. *
             * 
             */
            //updateRulesInShortMemoryUsingLifeCount(ruleListFromIDS);   
            
            // Delete flows that match with new rules in the networks switches.
            /*
             * TODO - Implement a method that permit simplify/summarize
             * the rules generated by itemsets algorithm. It means, if exist a
             * specific rule that match with a more general rule, we should
             * remove this specific rule (not send this command) and only send a
             * command to delete flows via the more generic rule, therefore just
             * one delete command is send to switches and not two this probably
             * will reduce the number of interruptions in the flows and probably
             * will gain performance. ie: 
             * first rule: 10.0.0.1:*->200.0.0.1:* (ICMP) 
             * second rule: 10.0.0.1:*->*:* (ICMP) 
             * 
             * In this case should be applied just
             * the second or send a command for the seconds rule because this
             * command also contemplate the first rule.
             */
            //deleteExistentsFlowsThatMatchWithNewRulesOnSwitches();
            // parei
            
            // Record rules at this moment in a file!
//            if (shortMemoryAttacks.size() > 0) {
//                writeRulesInShortMemoryToFile();
//            }
            
            /**
             * TODO - Feed long memory
             */
            
            if (CONFIG.DISABLE_JSON_OUTPUT==false) {
                writeRulesInShortMemoryToJsonFile();
            }
            
            // Time to waiting
            waitTimeInSeconds(TIME_TO_WAIT);
            log.debug("new processing memory attacks\n");
        }        
    }

    /**
     * Record/write the rules from short attacks memory in a Json file.
     * 
     */
    private void writeRulesInShortMemoryToJsonFile() {
        FileManager file = new FileManager("/home/luiz/Downloads/bootstrap-3.3.1/docs/examples/OfIDPS/", "rules.json");
        file.emptyFileContent();
        file.writeFile("{\"rules\": [");
//        for(String key : shortMemoryAttacks.keySet()) {
//            AlertMessage currentRule = shortMemoryAttacks.get(key);
//            file.writeFile(currentRule.getJsonMsgAlert()+",");
//        }
        
        for(Iterator<Map.Entry<String, AlertMessage>> rule = shortMemoryAttacks.entrySet().iterator();rule.hasNext();) {
            Map.Entry<String, AlertMessage> entry = rule.next();
            if(rule.hasNext()) {
            file.writeFile(entry.getValue().getJsonMsgAlert()+",");
            } else {
                file.writeFile(entry.getValue().getJsonMsgAlert());
            }
        }
        
        
        file.writeFile("]}");
    }
    
    /**
     * Record/write the security alerts in a Json file.
     * 
     */
    private void writeAlertsToJsonFile() {
        
        // TODO - under construction!
        
        FileManager file = new FileManager("/tmp/ofidps/", "alerts.json");
        file.createDirectory();
        file.writeFile("[");
        for(String key : shortMemoryAttacks.keySet()) {
            AlertMessage currentRule = shortMemoryAttacks.get(key);
            file.writeFile(currentRule.getJsonMsgAlert()+",");
        }
        file.writeFile("]");
    }
    
    /**
     * Record/write the rules in short attacks memory in a file.
     * 
     */
    private void writeRulesInShortMemoryToFile() {
        Date currentDate = new Date();
        SimpleDateFormat formatter = new SimpleDateFormat("yyyyMMdd_HHmmss");
        FileManager file = new FileManager("/tmp/ofidps/rules/"+formatter.format(dateTimeStartObject)+"/", formatter.format(currentDate));
        file.createDirectory();
        file.writeFile("Sensor time: "+ CONFIG.TIME_BETWEEN_RUN_SENSOR_OPENFLOW+
                ", short memory time: "+ CONFIG.TIME_TO_ALERTS_STAY_AT_SHORT_MEMORY+
                ", autonomic rules time: "+ CONFIG.TIME_BETWEEN_RUN_MEMORY_ATTACKS);
        for(String key : shortMemoryAttacks.keySet()) {
            AlertMessage currentRule = shortMemoryAttacks.get(key);
            file.writeFile(currentRule.getStringMsgAlert());
        }
    }
    
    /**
     * Convert OpenFlow alerts to be processed by itemset algorithm, it must be in the format:
     * Obs: this is similar to getAlertsFromSnortIDS() in IntrusionPreventionSystem
     * 
     * time,priorityAlert,alertDescription,networkSource,networkDestination,
     * networkProtocol,transportSource,transportDestination
     * 1,3,alerta1,167772162,167772161,6,0,666
     * 2,2,alerta2,167772162,167772161,6,0,777
     * 3,1,alerta3,167772162,167772161,6,0,888
     * 
     * In this example there are three alerts from host 10.0.0.2 to 10.0.0.1,
     * sourced from port 0 and destinated to ports 666,777,888 with alerts of
     * priority low, medium, and high.
     * 
     * @return a string with a list of attacks to be processed by SPMF
     * 
     */
    public String convertOpenFlowDoSAlertsToBeProcessedByItemsetsAlgorithm(List<AlertMessageSharePriority> listOfMaliciousFlows) {
        int numberOfAlerts=0;
        String sendToBeprocessedByApriori = "";
        for(AlertMessageSharePriority alert : listOfMaliciousFlows) {
                String regra = "src" + alert.getNetworkSource() + " dst"
                        + alert.getNetworkDestination() + " pro"
                        + alert.getNetworkProtocol() + " spo"
                        + alert.getTransportSource() + " dpo"
                        + alert.getTransportDestination() + " pri"
                        + alert.getPriorityAlert() + " des"
                        + alert.getAlertDescription() + "\n";

                sendToBeprocessedByApriori = sendToBeprocessedByApriori + regra;
                numberOfAlerts++;
        } // while
        log.debug("Amount of OpenFlow DoS alerts: {}!", numberOfAlerts);
        //log.debug("to send to apriori: \n {}",sendToBeprocessedByApriori);
        return sendToBeprocessedByApriori;
    }
    
    /**
     * Verify if this rule is new and send a OpenFlow Command to
     * delete/remove the related flows presents in the networks
     * switches.
     */
    private void deleteExistentsFlowsThatMatchWithNewRulesOnSwitches() {
//        ActuatorOpenFlow actuator = new ActuatorOpenFlow();
//        actuator.startUp(beaconProvider);
        for (String key : shortMemoryAttacks.keySet()) {
            AlertMessage currentRule = shortMemoryAttacks.get(key);
            if(currentRule.verifyNewRule()) {
                // Send a OpenFlow message to all networks switches to delete/remove this flow.
//                actuator.deleteFlowUsingCampsPresentsOnRuleInAllSwitches(currentRule);
                // The method changeBandwidthFlowUsingCampsPresentsOnRuleInAllSwitches don't work!
                //actuator.changeBandwidthFlowUsingCampsPresentsOnRuleInAllSwitches(currentRule);
                // Then this rules now is old!
                currentRule.disableNewRule();
            }
        }
//        actuator.shutDown();
    }
    
    /**
     * Obtain security rules from IDS alerts, using itemsets algorithm.
     * 
     * @param alertsFromIDSSnort - alerts obtained from Snort IDS
     * @param ruleListFromIDS - Map  
     * @return
     */
    private Map<String, AlertMessage> getRulesFromIDSAlertsUsingItensetsAlgorithm(String alertsFromIDSSnort) {
        Map<String,AlertMessage> ruleListFromIDS = new HashMap<String, AlertMessage>();
        DateFormat dateFormat = new SimpleDateFormat("yyyyMMDD_HHmmss");
        Date date = new Date();
        // TODO - Remove the write of output in file, this isn't necessary
        String output = "/tmp/output"+dateFormat.format(date)+".txt";  // the path for saving the frequent itemsets found
        AlgoFPGrowth_Strings algo = new AlgoFPGrowth_Strings();
        try {
            // Obtain rules from IDS alerts using itemsets algorithm. 
            ruleListFromIDS = algo.runAlgorithm(alertsFromIDSSnort,output);
            
        } catch (FileNotFoundException e) {
            log.debug("MemorysAttacks: Not is possible write on file {}", output);
            e.printStackTrace();
        } catch (IOException e) {
            log.debug("MemorysAttacks: Error on genetate rules from ataques to IDS");
            e.printStackTrace();
        }
        return ruleListFromIDS;
    }
    
    /**
     * 
     * In this method, we cleaned all rules in short memory and after, we put the
     * new rules generated by itemsets algorithm in the short memory.
     * 
     * This method is simple because we just controller the period of time to use the alerts
     * to generate new rules. 
     * 
     * @param ruleListFromIDS
     */
    private void updateRulesInShortMemoryUsingSimpleMethod(
            Map<String, AlertMessage> ruleListFromIDS) {
        // Remove all rules presents in the short memory
        shortMemoryAttacks.clear();
        if (ruleListFromIDS.size() <= 0) {
            log.debug("CAUTION! The itemsets algorithms didn't return rules, some possible reasons are: the IDSs hadn't alerts, the alerts returned by IDS has had your time out of the required time, the rules from IDS didn't reach the minimum support required, etc. ");
        } else {
            // Add rules obtained from the itemsets algorithm to the short memory.
            for (String key : ruleListFromIDS.keySet()) {
                AlertMessage regraAtual = ruleListFromIDS.get(key);
                // Print rule
                regraAtual.printMsgAlert();
                shortMemoryAttacks.put(key, regraAtual);
            }
        }
    }
    
    /**
     * This method merge new rules generated by itemsets algorithms with
     * existent rules, for this is used a timer count.
     * 
     * When new rules are added an OpenFlow command to delete/remove flows 
     * related with this rule are send for all switches on the network.
     * 
     * @param ruleListFromIDS
     */
    private void updateRulesInShortMemoryAndApplieThisRulesOnSwitches(
            Map<String, AlertMessage> ruleListFromIDS) {
        /**
         * TODO - Handle the inclusion of new rules and conflicts between
         * existent rules.
         * 
         * This is important to just remove/delete new flow in the switches
         * and not all flows like is make in updateRulesInShortMemoryUsingSimpleMethod.
         * 
         */
        
        ActuatorOpenFlow actuator = new ActuatorOpenFlow();
        actuator.startUp(beaconProvider);
                
        if (ruleListFromIDS.size() <= 0) {
            log.debug("CAUTION! The itemsets algorithms didn't return rules, some possible reasons are: the IDSs hadn't alerts, the alerts returned by IDS has had your time out of the required time, the rules from IDS didn't reach the minimum support required, etc. ");
        }
        
        int addedRules=0;
        int alreadyExistedRules=0;
        int removedRules=0;
        //log.debug("List of alerts rules AUTONOMIC generated:");
        
        // If exists rules put on the list of attacks in short memory
        for (String key : ruleListFromIDS.keySet()) {
            AlertMessage currentRule = ruleListFromIDS.get(key);
            String socketNetworkFromAlert = currentRule.getKeyFromNetworkSocket();
            AlertMessage oldRule = null;
            oldRule = shortMemoryAttacks.get(socketNetworkFromAlert);
            if (oldRule == null) {
                // If this rule don't exists just put on the short memory
                //log.debug("New rule alert added.");
                //currentRule.setTempo();
                
                // update/remove packets related with this rule on switches.
                actuator.deleteFlowUsingCampsPresentsOnRuleInAllSwitches(currentRule);
                
                currentRule.setLife();
                // TODO - We disable NewRule!
                //currentRule.setNewRule();
                //currentRule.printMsgAlert();
                shortMemoryAttacks.put(key, currentRule);
                addedRules++;                
            } else {
                /*
                 * If it rule already exists update your live.                     * 
                 */
                //log.debug("Rule already exist, then just update his life.");
                oldRule.setLife();
                // Get/maintain alert more danger.
                if(currentRule.getPriorityAlert() < oldRule.getPriorityAlert()) {
                    //log.debug("Alerts/rules with different priority!");
                    //oldRule.printMsgAlert();
                    //currentRule.printMsgAlert();
                    oldRule.setPriorityAlert(currentRule.getPriorityAlert());
                    oldRule.setAlertDescription(currentRule.getAlertDescription());
                    //oldRule.setNewRule();
                    
                    // update/remove packets related with this rule on switches.
                    actuator.deleteFlowUsingCampsPresentsOnRuleInAllSwitches(oldRule);
                }
                //oldRule.printMsgAlert();
                alreadyExistedRules++;
            }

        }
        /*
         * Old Remove rules that are dead..
         */
//        for(Iterator<Map.Entry<String, AlertMessage>> rule = shortMemoryAttacks.entrySet().iterator();rule.hasNext();) {
//            Map.Entry<String, AlertMessage> entry = rule.next();
//            entry.getValue().decreaseLife();
//            if(!entry.getValue().verifyLife()) {
//                //entry.getValue().printMsgAlert();
//                rule.remove();
//                //log.debug("Alert was removed, because your lives was expired!");
//                removedRules++;
//            }   
//        }
        
        /*
         * New - Remove rules that are dead, but passing priority gradually by: 
         * drop, bandwidth severe, soft and just only remove the rule.
         * 
         * If a rule yet have packets that combine arriving on the controller, 
         * this rule will be revived!
         * 
         */
        for(Iterator<Map.Entry<String, AlertMessage>> rule = shortMemoryAttacks.entrySet().iterator();rule.hasNext();) {
            Map.Entry<String, AlertMessage> entry = rule.next();
            
            /*
             * TEST - verify if the rule still in use on the controller (packets yet match)!
             * If is true update the time of life of this rules.
             * 
             * TODO - we will use the current priority or we will reconfigure the priority 
             * based on the number of packets that arrive on the controller?
             * 
             */
            entry.getValue().verifyAndUpdatePacketsMatchInOfControllerPerHop();
            
            
            entry.getValue().decreaseLife();
            if(!entry.getValue().verifyLife()) {
                int currentPriorityAlert =  entry.getValue().getPriorityAlert();
                // Before the rule be removed we pass them gradually:
                if(currentPriorityAlert==AlertMessage.ALERT_PRIORITY_HIGH) {
                    // If rule priority is High them we change to medium, and update the rule - not remove!
                    entry.getValue().printMsgAlert();
                    entry.getValue().setPriorityAlert(AlertMessage.ALERT_PRIORITY_MEDIUM);
                    entry.getValue().setLife();
                    //entry.getValue().increaseLife(3);
                    log.debug("priority changed from high to medium");
                    entry.getValue().printMsgAlert();
                    
                    // update/remove packets related with this rule on switches.
                    actuator.deleteFlowUsingCampsPresentsOnRuleInAllSwitches(entry.getValue());
                    alreadyExistedRules++;
                } else if (currentPriorityAlert==AlertMessage.ALERT_PRIORITY_MEDIUM) {
                    // If rule priority is medium them we change to low, and update the rule - not remove!
                    entry.getValue().printMsgAlert();
                    entry.getValue().setPriorityAlert(AlertMessage.ALERT_PRIORITY_LOW);
                    entry.getValue().setLife();
                    //entry.getValue().increaseLife(4);
                    log.debug("priority changed from medium to low");
                    entry.getValue().printMsgAlert();
                    
                    // update/remove packets related with this rule on switches.
                    actuator.deleteFlowUsingCampsPresentsOnRuleInAllSwitches(entry.getValue());
                    alreadyExistedRules++;
                } else {
                    // If rule priority is low them we remove this!
                    entry.getValue().printMsgAlert();
                    rule.remove();
                    //log.debug("Alert was removed, because your lives was expired!");
                    removedRules++;
                    log.debug("priority changed from low to normal - rule removed");
                    //entry.getValue().printMsgAlert();
                }
                
            }   
        }            
        log.debug("There are {} rules in short memory - {} new, {} already existed, {} removed", shortMemoryAttacks.size(),addedRules,alreadyExistedRules, removedRules);
        log.debug("Waiting {} seconds to rerun itemset algorithm and generate new AUTONOMIC rules",TIME_TO_WAIT);
        // aqui
        //printMemoryAttacks(shortMemoryAttacks);
        
        actuator.shutDown();
        
    }

    
    /**
     * This method merge new rules generated by itemsets algorithms with
     * existent rules, for this is used a timer count.
     * 
     * Attention during the tests this count didn't present good results...
     * apparently the rules must be maintained and compared with packets in on
     * the controller, not by anothers rules.
     * 
     * @param ruleListFromIDS
     */
    private void updateRulesInShortMemoryUsingLifeCount(
            Map<String, AlertMessage> ruleListFromIDS) {
        /**
         * TODO - Handle the inclusion of new rules and conflicts between
         * existent rules.
         * 
         * Maybe using a timer count: 1. Where rules that have this timer
         * set in zero are removed, if this rule don't appear in the new
         * autonomic generation made by itemsets algorithm. 2. But, if this
         * time is greater than zero, then this rule must be maintained on
         * the memory, and if this rule appear again on the autonomic
         * generation made by itemsets algorithm, then this rule should be
         * have this time count incremented.
         * 
         */
        // Remove all rules in short memory
        //shortMemoryAttacks.clear();
        
        if (ruleListFromIDS.size() <= 0) {
            log.debug("CAUTION! The itemsets algorithms didn't return rules, some possible reasons are: the IDSs hadn't alerts, the alerts returned by IDS has had your time out of the required time, the rules from IDS didn't reach the minimum support required, etc. ");
        }
        
        int addedRules=0;
        int alreadyExistedRules=0;
        int removedRules=0;
        //log.debug("List of alerts rules AUTONOMIC generated:");
        // If exists rules put on the list of attacks in short memory
        for (String key : ruleListFromIDS.keySet()) {
            AlertMessage regraAtual = ruleListFromIDS.get(key);
            String socketNetworkFromAlert = regraAtual.getKeyFromNetworkSocket();
            AlertMessage oldRule = null;
            oldRule = shortMemoryAttacks.get(socketNetworkFromAlert);
            if (oldRule == null) {
                // If this rule don't exists just put on the short memory
                log.debug("New rule alert added.");
                //regraAtual.setTempo();
                regraAtual.setLife();
                regraAtual.printMsgAlert();
                shortMemoryAttacks.put(key, regraAtual);
                addedRules++;
            } else {
                /*
                 * If it rule already exists update your live.                     * 
                 */
                oldRule.increaseLife();
                log.debug("Rule already exist, then just update his life.");
                oldRule.printMsgAlert();
                alreadyExistedRules++;
            }

        }
        /*
         * Remove rule that has your live.
         */
        for(Iterator<Map.Entry<String, AlertMessage>> rule = shortMemoryAttacks.entrySet().iterator();rule.hasNext();) {
            Map.Entry<String, AlertMessage> entry = rule.next();
            entry.getValue().decreaseLife();
            if(!entry.getValue().verifyLife()) {
                entry.getValue().printMsgAlert();
                rule.remove();
                log.debug("Alert has been removed, because your lives was expired!");
                removedRules++;
            }   
        }
                    
        log.debug("There are {} rules in short memory - {} new, {} already existed, {} removed", shortMemoryAttacks.size(),addedRules,alreadyExistedRules, removedRules);
        log.debug("Waiting {} seconds to rerun itemset algorithm and generate new AUTONOMIC rules",TIME_TO_WAIT);
    }
    
    
    
    public void startUp(IBeaconProvider bP) {
        // TODO Auto-generated method stub
        this.beaconProvider = bP;
        
    }
    
    /**
     * Print Maps of memory Attacks
     * 
     * @parm List of memory Attacks (Map<String,AlertMessage)
     */
    public void printMemoryAttacks(Map<String,AlertMessage> listMemoryAttacks) {
        log.debug("MemorysAttacks:printMemoryAttacks: ");
        for (String key : listMemoryAttacks.keySet()) {
            AlertMessage regraAtual = listMemoryAttacks.get(key);
            regraAtual.printMsgAlert();
        }
    }
    
    /**
     * Waiting a period of seconds 
     * 
     * @param timeInSeconds
     *            the Thread will wait a period of time.
     */
    private void waitTimeInSeconds(int timeInSeconds) {
        try {
            sleep(timeInSeconds * 1000);
        } catch (InterruptedException e) {
            log.debug("Problem with sleep in MemorysAttacks:waitTimeInSeconds");
            e.printStackTrace();
        }
    }
    
    public static String fileToPath(String filename) throws UnsupportedEncodingException{
        URL url = MemorysAttacks.class.getResource(filename);
         return java.net.URLDecoder.decode(url.getPath(),"UTF-8");
    }
    
}
