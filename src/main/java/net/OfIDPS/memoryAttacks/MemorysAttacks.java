/**
 * Manage attack memory using autonomic techniques to create security 
 * rules that will help to protect the network against security threats.
 * 
 * @author Luiz Arthur Feitosa dos Santos
 * @email luiz.arthur.feitosa.santos@gmail.com
 * 
 * TODO 1. Discover how long time a rule or alert must be in short memory?
 * 
 * TODO 2. When arriving packets match to installed security rules, 
 * this rules must be maintained for more time in the system. 
 * 
 * TODO 3. Must be implemented the alteration of already installed switches flows, to avoid overhead. For instance, the ability of change the bandwidth from an already installed flow in switches. 
 *  For now, to change one existent flow we needed:
 *      (i) delete this flow on the switch,
 *      (ii) wait that this same flows will be request by the hosts to the switch,
 *      (iii) the switch probably, will request this to OpenFlow controller, that will install this flow again using the new bandwidth control.
 * 
 * TODO 4 - implement a method that permit simplify/summarize
 * the rules generated by itemsets algorithm. It means, if exist a
 * specific rule that match with a more general rule, we should
 * remove this specific rule (not send this command) and only send a
 * command to delete flows via the more generic rule, therefore just
 * one delete command is send to switches and not two this probably
 * will reduce the number of interruptions in the flows and probably
 * will gain performance. ie: 
 * first rule: 10.0.0.1:*->200.0.0.1:* (ICMP) 
 * second rule: 10.0.0.1:*->*:* (ICMP) 
 * 
 * In this case should be applied just
 * the second or send a command for the seconds rule because this
 * command also contemplate the first rule.
 * 
 */


package net.OfIDPS.memoryAttacks;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.sql.SQLException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


import net.beaconcontroller.DAO.AlertOpenFlowDAO;
import net.beaconcontroller.DAO.StatusFlowDAO;
import net.beaconcontroller.IPS.AlertMessageSharePriority;
import net.beaconcontroller.IPS.IntrusionPreventionSystem;
import net.beaconcontroller.IPS.AlertMessage;
import net.beaconcontroller.IPS.SecurityAlerts;
import net.beaconcontroller.core.IBeaconProvider;
import net.beaconcontroller.tools.DateTimeManager;
import net.beaconcontroller.tools.FileManager;
import net.beaconcontroller.tutorial.ActuatorOpenFlow;
import net.beaconcontroller.tutorial.AnalysisFlow;
import net.beaconcontroller.tutorial.CONFIG;
import net.beaconcontroller.tutorial.LearningSwitchTutorialSolution;

public class MemorysAttacks extends Thread {
    
    protected IBeaconProvider beaconProvider;
       
    protected static Logger log = LoggerFactory
            .getLogger(LearningSwitchTutorialSolution.class);
    
    // Maps that represent the list of alerts security in memories.
    private Map<String,AlertMessage> shortMemoryAttacks;
    private Map<String,AlertMessage> longMemoryAttacks;
    private Map<String,AlertMessage> sensorialMemoryAttacks;
    private Map<String,AlertMessage> longMemoryForGoodRemembrances;
    
    // To run the long-term memory
    LongTermMemory longTermMemory = new LongTermMemory();
    
    /*
     * Period of time, in seconds, that an alert will be processed. This period
     * of time will be since the first time that it appear until the value in
     * this variables in seconds.
     */
    //public static int timeToAlertsStayAtShortMemory= CONFIG.TIME_TO_ALERTS_STAY_AT_SHORT_MEMORY;
    //public static int timeToAlertsStayAtSensorialMemory= CONFIG.TIME_TO_ALERTS_STAY_AT_SENSORIAL_MEMORY;
    //public static int timeToAlertsStayAtLongMemory= CONFIG.TIME_TO_ALERTS_STAY_AT_LONG_MEMORY;
    
    /*
     * Attributes used to disable or enable sensorial, short, and long memory.
     * 
     * 1 to disable and any other value to enable!
     */
    protected static int disableSensorialMemory=0;
    protected static int disableShortMemory=0;
    // To disable bad and good long memory.
    public static int disableLongMemory=0;
    // To disable only bad long memory.
    public static int disableLongBadMemory=0;
    // To disable only good long memory.
    public static int disableLongGoodMemory=0;
    
    /*
     * Time to wait until execute again the main method contained in the Thread (method run).
     */
    //public static int TIME_TO_WAIT = CONFIG.TIME_BETWEEN_RUN_MEMORY_ATTACKS;
    
    /*
     * USED TO IDENTIFY THE MEMORY TYPE.
     */
    public static final int MEMORY_SENSORIAL=1;
    public static final int MEMORY_SHORT=2;
    public static final int MEMORY_LONG_BAD=3;
    public static final int MEMORY_LONG_GOOD=4;
    
    /*
     * Order to be read/analyzed the memories rules:
     *      1       |     2     |     3     |   4
     * -------------|-----------|-----------|----------
     * longGood     | sensorial |sensorial  | sensorial
     * sensorial    | longGood  |short      | short
     * short        | short     |longGood   | longBad
     * longBad      | longBad   |longBad    |
     */
    public static final int MEMORY_ORDER_1_LONGGOOD_SENSORIAL_SHORT_LOGBAD=1;
    public static final int MEMORY_ORDER_2_SENSORIAL_LONGGOOD_SHORT_LONGBAD=2;
    public static final int MEMORY_ORDER_3_SENSORIAL_SHORT_LONGGOOD_LONGBAD=3;
    public static final int MEMORY_ORDER_4_SENSORIAL_SHORT_LONGBAD=4;
    
    // Attribute that deals with the order of the rules to be analyzed and applied in the Of-IDPS.
    public static final int MEMORY_ORDER_TO_BE_APPLIED_IN_THE_OFIDPS = MEMORY_ORDER_3_SENSORIAL_SHORT_LONGGOOD_LONGBAD;
    
    // Set when class start at first time!
    private static Date dateTimeStartObject = new Date();
    
    /**
     * Constructor method
     * 
     * @param shortMemoryAttacks - short memory
     * @param longMemoryAttacks - long memory
     * @param sensorialMemoryAttacks - sensorial memory
     */
    public MemorysAttacks (Map<String,AlertMessage> shortMemoryAttacks,
            Map<String,AlertMessage> longMemoryAttacks,
            Map<String,AlertMessage> sensorialMemoryAttacks,
            Map<String, AlertMessage> longMemoryForGoodRemembrances) {
        this.shortMemoryAttacks=shortMemoryAttacks;
        this.longMemoryAttacks=longMemoryAttacks;
        this.sensorialMemoryAttacks=sensorialMemoryAttacks;
        this.longMemoryForGoodRemembrances=longMemoryForGoodRemembrances;
    }
    
    /**
     * Constructor method - used by long memory. 
     */
    public MemorysAttacks ( ) {
        
    }
    
    /**
     *  Start the Thread
     */
    public void run() {
        log.debug("Start Thread that is responsible to construct memory from attacks");
        while (true) {
            
            /*
             * Get current datetime from system - to be used on to verify if alerts
             * will be in sensorial, short or long memory of attacks.
             */
            Calendar currentDate = Calendar.getInstance();
            
           
            
            
            /*******************************
             * Sensorial memory.
             *******************************/
            if(disableSensorialMemory!=1) {
                sensorialMemory();
            } else {
                log.debug("\t!!!!!!!! ATTENTION, Sensorial memory is DISABLED!!!!!!!!  to change this setup to 0 (zero) the variable disableSensorialMemory on MemoryAttacks class...");
            }
            
            /***************************
             * Feed short memory.
             ***************************/
            if(disableShortMemory!=1) {
                shortMemory();
            } else {
                log.debug("\t!!!!!!!! ATTENTION, Short memory is DISABLED!!!!!!!!  to change this setup to 0 (zero) the variable disableShortMemory on MemoryAttacks class...");
            }
            
            /**************************
             * Feed long memory.
             */
            /*
             * The long memory was moved to your own class, to run as thread! 
             * 
             * It was necessary because long memory normally has a lot of alerts, 
             * and recover this alerts from database and to process this, was 
             * consuming many time and disturbing both, sensorial and short memory.
             * 
             */
            
          log.debug("* Rules : {} sensorial, {} short, {} long bad, and {} long good !", 
          sensorialMemoryAttacks.size(),
          shortMemoryAttacks.size(),
          longMemoryAttacks.size(),
          longMemoryForGoodRemembrances.size());
            
            if (CONFIG.DISABLE_JSON_OUTPUT==false) {
                writeRulesInShortMemoryToJsonFile();
            }
            
            // Time to waiting
            log.debug("Waiting {} seconds to rerun Sensorial and Short-Term memory attacks\n", 
                    CONFIG.TIME_BETWEEN_RUN_MEMORY_ATTACKS);
            waitTimeInSeconds(CONFIG.TIME_BETWEEN_RUN_MEMORY_ATTACKS);
            
        }        
    }

    /**
     * Perform sensorial memory methods.
     * @param ids - An IntrusionPreventionSystem object to recover IDS alerts.
     * @param alertOpenFlowDAO - An AlertOpenFlowDAO object to recover OpenFlow alerts. 
     */
    private void sensorialMemory() {
        Date dateStart = DateTimeManager.getCurrentDate();
        
        // To store all alerts on security memory.
        List<AlertMessage> listOfAllAlertsInSensorialMemory =  new ArrayList<AlertMessage>();
        
        // Get all alerts to sensorial memory.
        SecurityAlerts securityAlerts = new SecurityAlerts();
        listOfAllAlertsInSensorialMemory = securityAlerts.getList_alerts_upToSecondsAgo(
                CONFIG.TIME_TO_ALERTS_STAY_AT_SENSORIAL_MEMORY, 
                "Sensorial Memory");
        
        // Remove old rules from sensorial memory to rerun the sensorial memory algorithm. 
        sensorialMemoryAttacks.clear();
        
        // Using returned alerts to create the rules of sensorial memory! Each returned alert will form two rules.
        for(AlertMessage alertMsg: listOfAllAlertsInSensorialMemory) {
            /*
             *  Attention, each alert must create two security rules!
             *  
             *      srcIP:* -> dstIP:dstPort (going)
             *      srcIP:srcPort -> dstIP:* (coming)
             *      
             *  It is necessary because, if we just create a rule with 
             *      srcIP:srcPort->dstIP:dstPort, 
             *  and remove this rule from network elements, the malicious 
             *  host will probably send again a new connection, that not will 
             *  combine with this rule, because will have, at least, 
             *  a new source port, that is random... 
             *  Then, it is better create a generic rule to the source port.
             *  
             *  Thus note that, we don't work with the complete fields from security alert:
             *  srcIP:srcPort -> dstIP:dstPort (going)
             *  
             *  It isn't necessary! Because the two more generic rules going/coming will 
             *  remove/deal this flow! Avoid overhead on the network...
             *  
             */
            AlertMessage alertGoing = getAlertGoing(alertMsg);
            AlertMessage alertComing = getAlertComing(alertMsg);

            // To verify if the rule already exists and avoid redundant rules.
            AlertMessage oldRuleGoing = null;
            oldRuleGoing = sensorialMemoryAttacks.get(alertGoing.getKeyFromNetworkSocket());
            
            // If rule not exist.
            if (oldRuleGoing == null) {
                // Put both: coming and going in the sensorial memory.
                sensorialMemoryAttacks.put(alertGoing.getKeyFromNetworkSocket(), alertGoing);
                sensorialMemoryAttacks.put(alertComing.getKeyFromNetworkSocket(), alertComing);
            } else {
                /*
                 * But if the rule already exist, get the highest security priority (more dangerous) 
                 * and put on the rule. Both, coming and going.
                 */
                if(alertGoing.getPriorityAlert() > oldRuleGoing.getPriorityAlert()) {
                    // Going rule.
                    oldRuleGoing.setPriorityAlert(alertGoing.getPriorityAlert());
                    oldRuleGoing.setAlertDescription(alertGoing.getAlertDescription());
                    
                    // Coming rule. 
                    AlertMessage oldRuleComing = sensorialMemoryAttacks.get(alertComing.getKeyFromNetworkSocket());
                    oldRuleComing.setPriorityAlert(alertComing.getPriorityAlert());
                    oldRuleComing.setAlertDescription(alertComing.getAlertDescription());
                }
            }
            
        }
        
        // Start the actuator module to remove bad flows from the network.
        /*
         * The actuator from sensorial memory is used to remove bad 
         * flows presents on the sensorial memory. 
         * In the short and long memory, the actuator is different!
         */
        if (sensorialMemoryAttacks.size() > 0) {
            ActuatorOpenFlow actuatorFromSensorialMemory = new ActuatorOpenFlow();
            actuatorFromSensorialMemory.startUp(beaconProvider);
            actuatorFromSensorialMemory.deleteAllFlowUsingCampsPresentsMemoryRulesInAllSwitches(sensorialMemoryAttacks);
            actuatorFromSensorialMemory.shutDown();
        }
        
        /*
         * TODO - Some bad flows aren't marked like bad on database,
         * because some flows weren't recorded on database yet...
         * (we have some seconds to record the flow on database) 
         * then instead of change the flows when the alert is emitted, we will look for alerts when 
         * we will record the flow on the database!
         */
        
        log.debug("> {} - alerts in sensorial memory, {} - rules in sensorial memory.", listOfAllAlertsInSensorialMemory.size(), sensorialMemoryAttacks.size());
        
        Date dateStop = DateTimeManager.getCurrentDate();
        long diffSeconds = DateTimeManager.differenceBetweenTwoDatesInMilliseconds(dateStart, dateStop);
        log.debug("End of SENSORIAL memory! {} - {} -> {} milliseconds", 
                DateTimeManager.dateToStringJavaDate(dateStart), 
                DateTimeManager.dateToStringJavaDate(dateStop),
                diffSeconds);
    }

    /**
     * Perform short-term memory methods.
     */
    private void shortMemory() {
        Date dateStart = DateTimeManager.getCurrentDate();
        // Get alerts from IDS and OpenFlow analysis to be processed by itemsets algorithm.
        SecurityAlerts securityAlerts = new SecurityAlerts();
//        String allAlerts = securityAlerts.getItemsetsString_Alerts_upToSecondsAgo(
//                timeToAlertsStayAtShortMemory,
//                "Short memory");
        String allAlerts = securityAlerts.getItemsetsString_FromAlerts(
                LongTermMemory.recoverRemembrancesUsing_3_getFromSecondsAgo,
                LongTermMemory.limit_to_recover_databaseFlows,
                CONFIG.TIME_TO_ALERTS_STAY_AT_SHORT_MEMORY,
                "Short memory");
        
        // Obtain rules from IDS alerts using itemsets algorithm.
        Map<String,AlertMessage> ruleListFromIDS = new HashMap<String, AlertMessage>();
        ruleListFromIDS = getSecurityRulesUsingItensetsAlgorithm(allAlerts);
        
        /*
         * Update rules on short memory and send this for all switches on the network.
         * here the delete/remove existent flows are inside of this method.
         * 
         */
        updateRulesInShortMemoryAndApplieThisRulesOnSwitches(ruleListFromIDS);
        
        /*
         * This didn't work very well: update rules on short memory, but
         * with this method all rules generated are sent for all switches
         * all the time (period that the rules are generated - 
         * waitTimeInSeconds(TIME_TO_WAIT)), then this
         * interrupt this flows and sends a lot of the OpenFlow Delete
         * messages all the time
         * 
         * If you want use this method you must implement or use a method
         * for delete/remove/update all related flows existent that already
         * are presents on the networks switches. *
         */
        //updateRulesInShortMemoryUsingSimpleMethod(ruleListFromIDS);
        
        
        /*
         * This didn't work very well:
         * TODO - The use of counter life didn't work very well, when the counter
         * is incremented by the own rules (if the rule generated is equal
         * to an existing rule)... maybe this will work if the increment it
         * is done by the new packets that match with this rules!
         * 
         * If you want use this method you must implement or use a method
         * for delete/remove/update all related flows existent that already
         * are presents on the networks switches. *
         * 
         */
        //updateRulesInShortMemoryUsingLifeCount(ruleListFromIDS);   
        
        // Delete flows that match with new rules in the networks switches.
        /*
         * TODO - Implement a method that permit simplify/summarize
         * the rules generated by itemsets algorithm. It means, if exist a
         * specific rule that match with a more general rule, we should
         * remove this specific rule (not send this command) and only send a
         * command to delete flows via the more generic rule, therefore just
         * one delete command is send to switches and not two this probably
         * will reduce the number of interruptions in the flows and probably
         * will gain performance. ie: 
         * first rule: 10.0.0.1:*->200.0.0.1:* (ICMP) 
         * second rule: 10.0.0.1:*->*:* (ICMP) 
         * 
         * In this case should be applied just
         * the second or send a command for the seconds rule because this
         * command also contemplate the first rule.
         */
        //deleteExistentsFlowsThatMatchWithNewRulesOnSwitches();
        // parei
        
        // Record rules at this moment in a file!
//            if (shortMemoryAttacks.size() > 0) {
//                writeRulesInShortMemoryToFile();
//            }
        Date dateStop = DateTimeManager.getCurrentDate();
        long diffSeconds = DateTimeManager.differenceBetweenTwoDatesInMilliseconds(dateStart, dateStop);
        log.debug("End of SHORT memory! {} - {} -> {} milliseconds", 
                DateTimeManager.dateToStringJavaDate(dateStart), 
                DateTimeManager.dateToStringJavaDate(dateStop),
                diffSeconds);   
    }
    




    /**
     * Get alert coming! 
     * The rule will be the alert with the reversed source and destination address/ports. 
     * 
     * @param alertMsg - An alert message...
     * @return - A rule based on security alert.
     * 
     * Remember that rule and alert are the same object!
     * 
     */
    private AlertMessage getAlertComing(AlertMessage alertMsg) {
        // Alert to packet that is coming - srcIP:* -> dstIP:dstPort
        AlertMessage alertComing = new AlertMessage();
        alertComing.setNetworkSource(alertMsg.getNetworkDestination());
        alertComing.setTransportSource(alertMsg.getTransportDestination());
        alertComing.setNetworkDestination(alertMsg.getNetworkSource());
        alertComing.setTransportDestination(Integer.MAX_VALUE);
        alertComing.setNetworkProtocol(alertMsg.getNetworkProtocol());
        alertComing.setPriorityAlert(alertMsg.getPriorityAlert());
        alertComing.setAlertDescription(alertMsg.getAlertDescription());
        return alertComing;
    }

    /**
     * Get alert going!
     * 
     * @param alertMsg - An alert message...
     * @return - A rule based on security alert
     * 
     * Remember that rule and alert are the same object!
     * 
     */
    private AlertMessage getAlertGoing(AlertMessage alertMsg) {
        // Alert to packet that is going - srcIP:srcPort -> dstIP:*
        AlertMessage alertGoing = new AlertMessage();
        alertGoing.setNetworkSource(alertMsg.getNetworkSource());
        alertGoing.setTransportSource(Integer.MAX_VALUE);
        alertGoing.setNetworkDestination(alertMsg.getNetworkDestination());
        alertGoing.setTransportDestination(alertMsg.getTransportDestination());
        alertGoing.setNetworkProtocol(alertMsg.getNetworkProtocol());
        alertGoing.setPriorityAlert(alertMsg.getPriorityAlert());
        alertGoing.setAlertDescription(alertMsg.getAlertDescription());
        return alertGoing;
    }

    /**
     * Update flows on database based on IDS alerts!
     * @param currentDate - Datetime
     * @param mapOfSnortAlertsSensorialToUpdateBadFlowsDB - Map with alerts that will generate the update on flows.
     */
    private void updateBadFlowsDB(
            Calendar currentDate,
            Map<String, AlertMessage> mapOfSnortAlertsSensorialToUpdateBadFlowsDB) {
        try {
            StatusFlowDAO statusFlowDAO = new StatusFlowDAO();
            for(String badKey : mapOfSnortAlertsSensorialToUpdateBadFlowsDB.keySet()) {
                AlertMessage badAlertFlow = new AlertMessage();
                badAlertFlow = mapOfSnortAlertsSensorialToUpdateBadFlowsDB.get(badKey);
                statusFlowDAO.updateBadFlow(badAlertFlow.getNetworkSource(),
                        badAlertFlow.getNetworkDestination(), 
                        badAlertFlow.getNetworkProtocol(),
                        badAlertFlow.getTransportSource(),
                        badAlertFlow.getTransportDestination(),
                        currentDate,
                        CONFIG.TIME_TO_ALERTS_STAY_AT_SENSORIAL_MEMORY+2
                        );
            }
        } catch (ClassNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    /**
     * Record/write the rules from short attacks memory in a Json file.
     * 
     */
    private void writeRulesInShortMemoryToJsonFile() {
        FileManager file = new FileManager("/home/luiz/Downloads/bootstrap-3.3.1/docs/examples/OfIDPS/", "rules.json");
        file.emptyFileContent();
        file.writeFile("{\"rules\": [");
//        for(String key : shortMemoryAttacks.keySet()) {
//            AlertMessage currentRule = shortMemoryAttacks.get(key);
//            file.writeFile(currentRule.getJsonMsgAlert()+",");
//        }
        
        for(Iterator<Map.Entry<String, AlertMessage>> rule = shortMemoryAttacks.entrySet().iterator();rule.hasNext();) {
            Map.Entry<String, AlertMessage> entry = rule.next();
            if(rule.hasNext()) {
            file.writeFile(entry.getValue().getJsonMsgAlert()+",");
            } else {
                file.writeFile(entry.getValue().getJsonMsgAlert());
            }
        }
        
        
        file.writeFile("]}");
    }
    
    /**
     * Record/write the security alerts in a Json file.
     * 
     */
    private void writeAlertsToJsonFile() {
        
        // TODO - under construction!
        
        FileManager file = new FileManager("/tmp/ofidps/", "alerts.json");
        file.createDirectory();
        file.writeFile("[");
        for(String key : shortMemoryAttacks.keySet()) {
            AlertMessage currentRule = shortMemoryAttacks.get(key);
            file.writeFile(currentRule.getJsonMsgAlert()+",");
        }
        file.writeFile("]");
    }
    
    /**
     * Record/write the rules in short attacks memory in a file.
     * 
     */
    private void writeRulesInShortMemoryToFile() {
        Date currentDate = new Date();
        SimpleDateFormat formatter = new SimpleDateFormat("yyyyMMdd_HHmmss");
        FileManager file = new FileManager("/tmp/ofidps/rules/"+formatter.format(dateTimeStartObject)+"/", formatter.format(currentDate));
        file.createDirectory();
        file.writeFile("Sensor time: "+ CONFIG.TIME_BETWEEN_RUN_SENSOR_OPENFLOW+
                ", short memory time: "+ CONFIG.TIME_TO_ALERTS_STAY_AT_SHORT_MEMORY+
                ", autonomic rules time: "+ CONFIG.TIME_BETWEEN_RUN_MEMORY_ATTACKS);
        for(String key : shortMemoryAttacks.keySet()) {
            AlertMessage currentRule = shortMemoryAttacks.get(key);
            file.writeFile(currentRule.getStringMsgAlert());
        }
    }
    
//    /**
//     * Convert OpenFlow alerts to be processed by itemset algorithm, it must be in the format:
//     * Obs: this is similar to getAlertsFromSnortIDS() in IntrusionPreventionSystem
//     * 
//     * time,priorityAlert,alertDescription,networkSource,networkDestination,
//     * networkProtocol,transportSource,transportDestination
//     * 1,3,alerta1,167772162,167772161,6,0,666
//     * 2,2,alerta2,167772162,167772161,6,0,777
//     * 3,1,alerta3,167772162,167772161,6,0,888
//     * 
//     * In this example there are three alerts from host 10.0.0.2 to 10.0.0.1,
//     * sourced from port 0 and destinated to ports 666,777,888 with alerts of
//     * priority low, medium, and high.
//     * 
//     * @return a string with a list of attacks to be processed by SPMF
//     * 
//     */
//    public String convertOpenFlowDoSAlertsToBeProcessedByItemsetsAlgorithm(List<AlertMessageSharePriority> listOfMaliciousFlows) {
//        int numberOfAlerts=0;
//        String sendToBeprocessedByApriori = "";
//        for(AlertMessageSharePriority alert : listOfMaliciousFlows) {
//                String regra = "src" + alert.getNetworkSource() + " dst"
//                        + alert.getNetworkDestination() + " pro"
//                        + alert.getNetworkProtocol() + " spo"
//                        + alert.getTransportSource() + " dpo"
//                        + alert.getTransportDestination() + " pri"
//                        + alert.getPriorityAlert() + " des"
//                        + alert.getAlertDescription() + "\n";
//
//                sendToBeprocessedByApriori = sendToBeprocessedByApriori + regra;
//                numberOfAlerts++;
//        } // while
//        log.debug("Amount of OpenFlow DoS alerts: {}!", numberOfAlerts);
//        //log.debug("to send to apriori: \n {}",sendToBeprocessedByApriori);
//        return sendToBeprocessedByApriori;
//    }
    
    /**
     * Convert Of-IDPS alerts to the required format to be processed by the itemsets algorithm.
     * 
     * time,priorityAlert,alertDescription,networkSource,networkDestination,
     * networkProtocol,transportSource,transportDestination
     * 1,3,alerta1,167772162,167772161,6,0,666
     * 2,2,alerta2,167772162,167772161,6,0,777
     * 3,1,alerta3,167772162,167772161,6,0,888
     * 
     * In this example there are three alerts from host 10.0.0.2 to 10.0.0.1,
     * originated from port 0 and destined to ports 666,777,888 with alerts of
     * priority low, medium, and high.
     * 
     * @return a string with a list of attacks to be processed by SPMF
     * 
     */
//    public String convertAlertMessagesToBeProcessedByItemsetsAlgorithm(List<AlertMessage> listOfSnortAlerts) {
//        String sendToBeprocessedByApriori = "";
//        for (AlertMessage alertMsg : listOfSnortAlerts) {
//            // alertMsg.printMsgAlert();
//            // log.debug("{}->{}",
//            // IPv4.fromIPv4Address(alertMsg.getNetworkSource()),
//            // IPv4.fromIPv4Address(alertMsg.getNetworkDestination()));
//            String rule = "src" + alertMsg.getNetworkSource() + " dst"
//                    + alertMsg.getNetworkDestination() + " pro"
//                    + alertMsg.getNetworkProtocol() + " spo"
//                    + alertMsg.getTransportSource() + " dpo"
//                    + alertMsg.getTransportDestination() + " pri"
//                    + alertMsg.getPriorityAlert() + " des"
//                    + alertMsg.getAlertDescription() + "\n";
//
//            sendToBeprocessedByApriori = sendToBeprocessedByApriori + rule;
//
//        }
//        //log.debug("\n"+sendToBeprocessedByApriori);
//        return sendToBeprocessedByApriori;
//    }
    
    /**
     * Verify if this rule is new and send a OpenFlow Command to
     * delete/remove the related flows presents in the networks
     * switches.
     */
    private void deleteExistentsFlowsThatMatchWithNewRulesOnSwitches() {
//        ActuatorOpenFlow actuator = new ActuatorOpenFlow();
//        actuator.startUp(beaconProvider);
        for (String key : shortMemoryAttacks.keySet()) {
            AlertMessage currentRule = shortMemoryAttacks.get(key);
            if(currentRule.verifyNewRule()) {
                // Send a OpenFlow message to all networks switches to delete/remove this flow.
//                actuator.deleteFlowUsingCampsPresentsOnRuleInAllSwitches(currentRule);
                // The method changeBandwidthFlowUsingCampsPresentsOnRuleInAllSwitches don't work!
                //actuator.changeBandwidthFlowUsingCampsPresentsOnRuleInAllSwitches(currentRule);
                // Then this rules now is old!
                currentRule.disableNewRule();
            }
        }
//        actuator.shutDown();
    }
    
    /**
     * Obtain security rules using itemsets algorithm.
     * 
     * @param - alertsFromIDSSnort - alerts obtained from Snort IDS.
     * @param - ruleListFromIDS - Map.  
     * @return - List of rules.
     */
    public Map<String, AlertMessage> getSecurityRulesUsingItensetsAlgorithm(String alertsFromIDSSnort) {
        Map<String,AlertMessage> ruleListFromIDS = new HashMap<String, AlertMessage>();
        DateFormat dateFormat = new SimpleDateFormat("yyyyMMDD_HHmmss");
        Date date = new Date();
        // TODO - Remove the write of output in file, this isn't necessary
        String output = "/tmp/OfIDPS_output_rule.txt";  // the path for saving the frequent itemsets found
        AlgoFPGrowth_Strings algo = new AlgoFPGrowth_Strings();
        try {
            // Obtain rules from IDS alerts using itemsets algorithm. 
            ruleListFromIDS = algo.runAlgorithm(alertsFromIDSSnort,output);
            
        } catch (FileNotFoundException e) {
            log.debug("MemorysAttacks: Not is possible write on file {}", output);
            e.printStackTrace();
        } catch (IOException e) {
            log.debug("MemorysAttacks: Error on genetate rules from ataques to IDS");
            e.printStackTrace();
        }
        return ruleListFromIDS;
    }
    
    /**
     * 
     * In this method, we cleaned all rules in short memory and after, we put the
     * new rules generated by itemsets algorithm in the short memory.
     * 
     * This method is simple because we just controller the period of time to use the alerts
     * to generate new rules. 
     * 
     * @param ruleListFromIDS
     */
    private void updateRulesInShortMemoryUsingSimpleMethod(
            Map<String, AlertMessage> ruleListFromIDS) {
        // Remove all rules presents in the short memory
        shortMemoryAttacks.clear();
        if (ruleListFromIDS.size() <= 0) {
            log.debug("CAUTION! The itemsets algorithms didn't return rules, some possible reasons are: the IDSs hadn't alerts, the alerts returned by IDS has had your time out of the required time, the rules from IDS didn't reach the minimum support required, etc. ");
        } else {
            // Add rules obtained from the itemsets algorithm to the short memory.
            for (String key : ruleListFromIDS.keySet()) {
                AlertMessage regraAtual = ruleListFromIDS.get(key);
                // Print rule
                regraAtual.printMsgAlert();
                shortMemoryAttacks.put(key, regraAtual);
            }
        }
    }
    
    /**
     * This method merge new rules generated by itemsets algorithms with
     * existent rules, for this is used a timer count.
     * 
     * When new rules are added an OpenFlow command to delete/remove flows 
     * related with this rule are send for all switches on the network.
     * 
     * @param ruleListFromIDS
     */
    private void updateRulesInShortMemoryAndApplieThisRulesOnSwitches(
            Map<String, AlertMessage> ruleListFromIDS) {
        /**
         * TODO - Handle the inclusion of new rules and conflicts between
         * existent rules.
         * 
         * This is important to just remove/delete new flow in the switches
         * and not all flows like is make in updateRulesInShortMemoryUsingSimpleMethod.
         * 
         */
        
        ActuatorOpenFlow actuator = new ActuatorOpenFlow();
        actuator.startUp(beaconProvider);
                
        if (ruleListFromIDS.size() <= 0) {
            log.debug("CAUTION! The itemsets algorithms didn't return rules, some possible reasons are: the IDSs hadn't alerts, the alerts returned by IDS has had your time out of the required time, the rules from IDS didn't reach the minimum support required, etc. ");
        }
        
        int addedRules=0;
        int alreadyExistedRules=0;
        int removedRules=0;
        //log.debug("List of alerts rules AUTONOMIC generated:");
        
        // If exists rules put on the list of attacks in short memory
        for (String key : ruleListFromIDS.keySet()) {
            AlertMessage currentRule = ruleListFromIDS.get(key);
            String socketNetworkFromAlert = currentRule.getKeyFromNetworkSocket();
            AlertMessage oldRule = null;
            oldRule = shortMemoryAttacks.get(socketNetworkFromAlert);
            if (oldRule == null) {
                // If this rule don't exists just put on the short memory
                //log.debug("New rule alert added.");
                //currentRule.setTempo();
                
                // update/remove packets related with this rule on switches.
                actuator.deleteFlowUsingCampsPresentsOnRuleInAllSwitches(currentRule);
                
                currentRule.setLife();
                // TODO - We disable NewRule!
                //currentRule.setNewRule();
                //currentRule.printMsgAlert();
                shortMemoryAttacks.put(key, currentRule);
                addedRules++;                
            } else {
                /*
                 * If it rule already exists update your live.                     * 
                 */
                //log.debug("Rule already exist, then just update his life.");
                oldRule.setLife();
                // Get/maintain alert more danger.
                if(currentRule.getPriorityAlert() < oldRule.getPriorityAlert()) {
                    //log.debug("Alerts/rules with different priority!");
                    //oldRule.printMsgAlert();
                    //currentRule.printMsgAlert();
                    oldRule.setPriorityAlert(currentRule.getPriorityAlert());
                    oldRule.setAlertDescription(currentRule.getAlertDescription());
                    //oldRule.setNewRule();
                    
                    // update/remove packets related with this rule on switches.
                    actuator.deleteFlowUsingCampsPresentsOnRuleInAllSwitches(oldRule);
                }
                //oldRule.printMsgAlert();
                alreadyExistedRules++;
            }

        }
        /*
         * Old Remove rules that are dead..
         */
//        for(Iterator<Map.Entry<String, AlertMessage>> rule = shortMemoryAttacks.entrySet().iterator();rule.hasNext();) {
//            Map.Entry<String, AlertMessage> entry = rule.next();
//            entry.getValue().decreaseLife();
//            if(!entry.getValue().verifyLife()) {
//                //entry.getValue().printMsgAlert();
//                rule.remove();
//                //log.debug("Alert was removed, because your lives was expired!");
//                removedRules++;
//            }   
//        }
        
        /*
         * New - Remove rules that are dead, but passing priority gradually by: 
         * drop, bandwidth severe, soft and just only remove the rule.
         * 
         * If a rule yet have packets that combine arriving on the controller, 
         * this rule will be revived!
         * 
         */
        for(Iterator<Map.Entry<String, AlertMessage>> rule = shortMemoryAttacks.entrySet().iterator();rule.hasNext();) {
            Map.Entry<String, AlertMessage> entry = rule.next();
            
            /*
             * TEST - verify if the rule still in use on the controller (packets yet match)!
             * If is true update the time of life of this rules.
             * 
             * TODO - we will use the current priority or we will reconfigure the priority 
             * based on the number of packets that arrive on the controller?
             * 
             */
            entry.getValue().verifyAndUpdatePacketsMatchInOfControllerPerHop();
            
            
            entry.getValue().decreaseLife();
            if(!entry.getValue().verifyLife()) {
                int currentPriorityAlert =  entry.getValue().getPriorityAlert();
                // Before the rule be removed we pass them gradually:
                if(currentPriorityAlert==AlertMessage.ALERT_PRIORITY_HIGH) {
                    // If rule priority is High them we change to medium, and update the rule - not remove!
                    entry.getValue().printMsgAlert();
                    entry.getValue().setPriorityAlert(AlertMessage.ALERT_PRIORITY_MEDIUM);
                    entry.getValue().setLife();
                    //entry.getValue().increaseLife(3);
                    log.debug("priority changed from high to medium");
                    entry.getValue().printMsgAlert();
                    
                    // update/remove packets related with this rule on switches.
                    actuator.deleteFlowUsingCampsPresentsOnRuleInAllSwitches(entry.getValue());
                    alreadyExistedRules++;
                } else if (currentPriorityAlert==AlertMessage.ALERT_PRIORITY_MEDIUM) {
                    // If rule priority is medium them we change to low, and update the rule - not remove!
                    entry.getValue().printMsgAlert();
                    entry.getValue().setPriorityAlert(AlertMessage.ALERT_PRIORITY_LOW);
                    entry.getValue().setLife();
                    //entry.getValue().increaseLife(4);
                    log.debug("priority changed from medium to low");
                    entry.getValue().printMsgAlert();
                    
                    // update/remove packets related with this rule on switches.
                    actuator.deleteFlowUsingCampsPresentsOnRuleInAllSwitches(entry.getValue());
                    alreadyExistedRules++;
                } else {
                    // If rule priority is low them we remove this!
                    //entry.getValue().printMsgAlert();
                    rule.remove();
                    //log.debug("Alert was removed, because your lives was expired!");
                    removedRules++;
                    //log.debug("priority changed from low to normal - rule removed");
                    //entry.getValue().printMsgAlert();
                }
                
            }   
        }            
        log.debug(">> Rules in short memory: total {} ({} new/{} existing/{} removed) - " +
        		" {} new rules that match with existing old rules.", 
                shortMemoryAttacks.size(),
                addedRules,
                shortMemoryAttacks.size()-addedRules,
                removedRules,
                alreadyExistedRules);
        log.debug("Waiting {} seconds to rerun itemset algorithm and generate new AUTONOMIC rules",
                CONFIG.TIME_BETWEEN_RUN_MEMORY_ATTACKS);
        //printMemoryAttacks(shortMemoryAttacks);
        
        actuator.shutDown();
        
    }

    
    /**
     * This method merge new rules generated by itemsets algorithms with
     * existent rules, for this is used a timer count.
     * 
     * Attention during the tests this count didn't present good results...
     * apparently the rules must be maintained and compared with packets in on
     * the controller, not by anothers rules.
     * 
     * @param ruleListFromIDS
     */
    private void updateRulesInShortMemoryUsingLifeCount(
            Map<String, AlertMessage> ruleListFromIDS) {
        /**
         * TODO - Handle the inclusion of new rules and conflicts between
         * existent rules.
         * 
         * Maybe using a timer count: 1. Where rules that have this timer
         * set in zero are removed, if this rule don't appear in the new
         * autonomic generation made by itemsets algorithm. 2. But, if this
         * time is greater than zero, then this rule must be maintained on
         * the memory, and if this rule appear again on the autonomic
         * generation made by itemsets algorithm, then this rule should be
         * have this time count incremented.
         * 
         */
        // Remove all rules in short memory
        //shortMemoryAttacks.clear();
        
        if (ruleListFromIDS.size() <= 0) {
            log.debug("CAUTION! The itemsets algorithms didn't return rules, some possible reasons are: the IDSs hadn't alerts, the alerts returned by IDS has had your time out of the required time, the rules from IDS didn't reach the minimum support required, etc. ");
        }
        
        int addedRules=0;
        int alreadyExistedRules=0;
        int removedRules=0;
        //log.debug("List of alerts rules AUTONOMIC generated:");
        // If exists rules put on the list of attacks in short memory
        for (String key : ruleListFromIDS.keySet()) {
            AlertMessage regraAtual = ruleListFromIDS.get(key);
            String socketNetworkFromAlert = regraAtual.getKeyFromNetworkSocket();
            AlertMessage oldRule = null;
            oldRule = shortMemoryAttacks.get(socketNetworkFromAlert);
            if (oldRule == null) {
                // If this rule don't exists just put on the short memory
                log.debug("New rule alert added.");
                //regraAtual.setTempo();
                regraAtual.setLife();
                regraAtual.printMsgAlert();
                shortMemoryAttacks.put(key, regraAtual);
                addedRules++;
            } else {
                /*
                 * If it rule already exists update your live.                     * 
                 */
                oldRule.increaseLife();
                log.debug("Rule already exist, then just update his life.");
                oldRule.printMsgAlert();
                alreadyExistedRules++;
            }

        }
        /*
         * Remove rule that has your live.
         */
        for(Iterator<Map.Entry<String, AlertMessage>> rule = shortMemoryAttacks.entrySet().iterator();rule.hasNext();) {
            Map.Entry<String, AlertMessage> entry = rule.next();
            entry.getValue().decreaseLife();
            if(!entry.getValue().verifyLife()) {
                entry.getValue().printMsgAlert();
                rule.remove();
                log.debug("Alert has been removed, because your lives was expired!");
                removedRules++;
            }   
        }
                    
        log.debug("There are {} rules in short memory - {} new, {} already existed, {} removed", shortMemoryAttacks.size(),addedRules,alreadyExistedRules, removedRules);
        log.debug("Waiting {} seconds to rerun itemset algorithm and generate new AUTONOMIC rules",
                CONFIG.TIME_BETWEEN_RUN_MEMORY_ATTACKS);
    }
    
    
    
    public void startUp(IBeaconProvider bP) {
        // TODO Auto-generated method stub
        this.beaconProvider = bP;
        
        // Run the long-term memory as thread
        longTermMemory.startUp(beaconProvider ,longMemoryAttacks, longMemoryForGoodRemembrances);
        longTermMemory.start();
        
    }
    
    /**
     * Print Maps of memory Attacks
     * 
     * @parm List of memory Attacks (Map<String,AlertMessage)
     */
    public void printMemoryAttacks(Map<String,AlertMessage> listMemoryAttacks) {
        log.debug("MemorysAttacks:printMemoryAttacks: ");
        for (String key : listMemoryAttacks.keySet()) {
            AlertMessage regraAtual = listMemoryAttacks.get(key);
            regraAtual.printMsgAlert();
        }
    }
    
    /**
     * Waiting a period of seconds 
     * 
     * @param timeInSeconds
     *            the Thread will wait a period of time.
     */
    private void waitTimeInSeconds(int timeInSeconds) {
        try {
            sleep(timeInSeconds * 1000);
        } catch (InterruptedException e) {
            log.debug("Problem with sleep in MemorysAttacks:waitTimeInSeconds");
            e.printStackTrace();
        }
    }
    
    public static String fileToPath(String filename) throws UnsupportedEncodingException{
        URL url = MemorysAttacks.class.getResource(filename);
         return java.net.URLDecoder.decode(url.getPath(),"UTF-8");
    }
    
}
